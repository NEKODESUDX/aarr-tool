<!DOCTYPE html>
<html lang="ja">
<head>
   <meta charset="UTF-8">
   <title>AARR tool</title>
   <meta name="description" content="message tool">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <meta name="theme-color" content="blue">
   <meta property="og:title" content="AARR tool">
   <meta property="og:description" content="メッセージ送信ツールです">
   <meta property="og:image" content="https://i.imgur.com/rApLvfn.png">
   <link rel="stylesheet" href="style.css">

   <style>
body {
    font-family: Arial, sans-serif;
    background-color: #0f0f0f;
    color: #fff;
    margin: 0;
    padding: 20px;
    display: flex;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    min-height: 100vh;
}

#app {
    width: 100%;
    background-color: #333;
    padding: 20px;
    border-radius: 0;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    margin-bottom: 20px;
}

h1, h2 {
    color: white;
    margin: 0 0 10px;
}

.description {
    background-color: #202225;
    padding: 15px;
    border-radius: 0;
    margin-bottom: 20px;
    color: #B9BBBE;
}
input, textarea {
    width: 90vw; 
    margin-top: 5px;
    padding: 10px;
    font-size: 16px;
    background-color: #333;
    border: 1px solid #ccc;
    border-radius: 0;
    color: white;
    outline: none;
}

textarea {
    resize: vertical;
    height: 100px;
}

button {
    cursor: pointer;
    background-color: #333333;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 0;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
    margin-top: 10px;
}

button:hover {
    background-color: #45a049;
    box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
}

button:active {
    background-color: #2e8b57;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    transform: scale(0.98);
}

button:disabled {
    background-color: #4F545C;
    cursor: not-allowed;
    box-shadow: none;
}

.card {
    background-color: #202225;
    padding: 15px;
    border-radius: 0;
    margin-bottom: 20px;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
}

a {
    color: #45a049;
    text-decoration: none;
}

a:hover {
    text-decoration: underline;
}

#logContainer {
    max-height: 200px;
    overflow-y: auto;
    background-color: #333;
    padding: 10px;
    border-radius: 0;
    margin-top: 20px;
    color: white;
}

.poll-input {
    width: 100%;
    margin-top: 5px;
    padding: 10px;
    background-color: #333;
    border: 1px solid #ccc;
    border-radius: 0;
    color: white;
    font-size: 16px;
}

#pollOptions input[type="checkbox"] {
    transform: scale(1.5);
    margin-right: 5px;
}

#pollOptions label {
    margin: 0;
    font-size: 16px;
    color: white;
}

#serverId {
    width: 100%;
    margin-top: 5px;
    padding: 10px;
    background-color: #333;
    border: 1px solid #ccc;
    border-radius: 0;
    color: white;
    font-size: 16px;
}

   </style>
</head>
<body>
   <div id="app">
         <h1>AARR tool</h1>
<div class="description">
     <p>Web Tool</p>
    <a href="https://discord.gg/DPmPdpcNqs" target="_blank">開発者サポートサーバー (Discord)</a><br>
    <a href="https://youtu.be/NTrzk7bxotg?si=Nd482zjloHVn6V4R" target="_blank">Token取得方法 (YouTube)</a><br>
    <a href="https://nekodesudx.github.io/DM/" target="_blank">グループ追加ツール (GitHub)</a><br>
    <a href="https://nekodesudx.github.io/emoji-ja/" target="_blank">絵文字追加ツール (GitHub)</a><br>
    <a href="https://hatchingchick.github.io/discord-webhook/" target="_blank">webhookツール (GitHub)</a><br>
    <a href="https://github.com/NEKODESUDX/AARR-py/tree/main" target="_blank">リアクション追加ツール (GitHub)</a><br>

    <h2>依存環境</h2>
    <a href="https://www.tampermonkey.net/" target="_blank">①tampermonkey [必須]</a><br>
    <a href="https://greasyfork.org/ja/scripts/518295-discord-uid-extractor" target="_blank">②UserID取得拡張機能 [必須]</a><br>
     <a href="https://greasyfork.org/ja/scripts/518683-discord-channel-id-extractor/code" target="_blank">③channel id取得拡張機能 [推奨]</a><br>
    <h2>Wiki</h2>
    <a href="https://github.com/hatchingchick/wiki/wiki/%E8%8D%92%E3%82%89%E3%81%97%E3%81%AE%E3%83%87%E3%83%BC%E3%82%BF%E3%83%99%E3%83%BC%E3%82%B9" target="_blank">荒らしのテクニックなど</a><br>

    <h2>Note:</h2>
    <p>このツールはGitHub上で動作するブラウザツールであるため、joinは手動で行う必要があります。</p>
    <p>ランダムメンションの数を増やし過ぎるとAutoModに検知されやすくなります。</p>
    <p>また、サーバーによっては自動検知されることがあります。</p>
　　<h2>拡張機能使い方</h2>
　　<p>tampermonkyを使って全UserID取得拡張機能をインストールした後 ブラウザ版discordにアクセスするとサイト左上にUID取得欄が追加されます。取得したら改行で区切ってこのツールのユーザーID欄に入力してください(拡張機能は依存環境を参照)</p>
</div>

       </div>
       <div class="card">
           <label for="tokenField">トークン:</label>
           <textarea id="tokenField" placeholder="ユーザートークンを改行で区切って入力"></textarea>
       </div>
       <div class="card">
    <label for="serverId">サーバーID:</label>
    <input type="text" id="serverId" placeholder="DiscordサーバーIDを入力">
    <button id="showWidget">IDからウィジェットを表示</button>
</div>

<div class="card" id="widgetContainer" style="margin-top: 20px; display: none;">
    <h3>サーバーウィジェット</h3>
    <iframe id="discordWidget" 
            width="350" 
            height="500" 
            allowtransparency="true" 
            frameborder="0" 
            sandbox="allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts">
    </iframe>
</div>

       <div class="card">
           <label for="inputChannelId">チャンネルID:</label>
           <textarea id="inputChannelId" placeholder="発言するチャンネルのIDを改行で区切って入力"></textarea>
           <button id="copyChannelId">コピー</button>
           <button id="clearChannelId">クリア</button>
       </div>
       <div class="card">
           <label for="inputUserId">ユーザーID:</label>
           <textarea id="inputUserId" placeholder="メンションするユーザーのIDを改行で区切って入力"></textarea>
       </div>
   <div class="card"> 
      <label for="blacklistUID">ブラックリストUID:</label> 
      <textarea id="blacklistUID" placeholder="メンションしないユーザーのIDを改行で区切って入力"></textarea> 
   </div>
       <div class="card">
           <label for="inputContent">発言内容:</label>
           <textarea id="inputContent" placeholder="発言する内容を入力(空の場合は点呼)"></textarea>
           <button id="copyContent">コピー</button>
           <button id="clearContent">クリア</button>
       </div>
       <div class="card">
           <label for="messageCount">発言回数:</label>
           <input id="messageCount" type="number" value="9999" min="1">
       </div>
       <div class="card">
           <label for="delay">遅延(ミリ秒):</label>
           <input id="delay" type="number" value="1000" min="0">
       </div>
       <div class="card">
           <label for="mentionCount">ランダムメンションの数:</label>
           <input id="mentionCount" type="number" value="1" min="0">
       </div>
  <div class="card">
    <div style="display: flex; align-items: center; margin-bottom: 15px;">
        <label for="includePoll" style="font-size: 16px; margin: 0;">投票を含める</label>
    </div>
    <div id="pollOptions" style="margin-top: 10px;">
        <label for="pollTitle">投票タイトル:</label>
        <input type="text" id="pollTitle" placeholder="投票のタイトルを入力" class="poll-input">
        <br>
        <label for="pollAnswers">投票の回答 (カンマ区切り):</label>
        <input type="text" id="pollAnswers" placeholder="例: 回答1,回答2" class="poll-input">
        <br>
        <label for="pollDuration">開催期間 (1/4/8/24/72/168/336):</label>
        <input type="number" id="pollDuration" value="1" placeholder="例: 24" class="poll-input">
    </div>
</div>
<div class="card">
    <label for="inputRandom">発言の最後にランダムな文字を追加:</label>
     <input type="checkbox" id="inputRandom" style="transform: scale(1.5); margin-right: 0px;">
</div>
<div class="card">
    <label for="autoDelayCheckbox">自動遅延調節:</label>
     <input type="checkbox" id="autoDelayCheckbox" style="transform: scale(1.5); margin-right: 0px;">
</div>
</div>
<label for="startDelay">送信開始までの時間 (分後):</label>
<input type="number" id="startDelay" name="startDelay" value="0" min="0">
       <button id="sayButton">送信開始(⚠️連打するとリクエストが2倍になります)</button>
       <button id="typingButton">入力中</button>
   </div>
   <div class="card">

    <label for="threadTitle">スレッドタイトル:</label>
    <input type="text" id="threadTitle" placeholder="スレッドのタイトルを入力" class="thread-input">
    <br>
    <label for="threadMessage">スレッドのメッセージ:</label>
    <input type="text" id="threadMessage" placeholder="ここにスレッドメッセージを入力" class="thread-input">
    <br>
    <label for="threadCount">作成回数:</label>
    <input type="number" id="threadCount" value="9999" class="thread-input">
    <br>
    <label for="threadDelay">遅延 (ミリ秒):</label>
    <input type="number" id="threadDelay" value="30000" placeholder="推奨:30秒" class="thread-input">
    <br>
      <label for="threadType">スレッドのタイプ:</label> 
      <select id="threadType" class="thread-input">
         <option value="normal">通常</option>
         <option value="announcement">アナウンス</option>
    <button onclick="createThreads()">スレッド送信開始</button>
</div>
<div class="card">
    <body>
        <div class="container">
            <p>イベント作成</p>
           <p>⚠️エクスプレッション権限に未対応</p>
            <div class="form-group">
            <div class="form-group">
                <label for="guildId">サーバーID：</label>
                <input type="text" id="guildId">
            </div>
            <div class="form-group">
                <label for="eventName">イベント名：</label>
                <input type="text" id="eventName">
            </div>
            <div class="form-group">
                <label for="eventDescription">イベント概要：</label>
                <textarea id="eventDescription" rows="4"></textarea>
            </div>
            <div class="form-group">
                <label for="eventLocation">ロケーション：</label>
                <input type="text" id="eventLocation">
            </div>
            <div class="form-group">
                <label for="eventStartTime">開始日時(UTC標準時)：</label>
                <input type="text" id="eventStartTime" value="2024-12-15T17:00:00Z">
            </div>
            <div class="form-group">
                <label for="eventEndTime">終了日時(UTC標準時)：</label>
                <input type="text" id="eventEndTime" value="2024-12-15T19:00:00Z">
            </div>
            <div class="form-group">
                <label for="eventCount">イベント作成回数：</label>
                <input type="number" id="eventCount" value="1">
            </div>
            <div class="form-group">
                <label for="eventDelay">遅延時間（ミリ秒）：</label>
                <input type="number" id="eventDelay" value="1000">
            </div>
            <button id="createEventsButton">イベントを作成</button>
            <div id="status"></div>
        </div>

     <div class="container">
            <form id="emojiForm">
            <br>
            <p>絵文字追加</p>
               <p>⚠️エクスプレッション権限に未対応</p>
            <label for="guildId">サーバーID (Guild ID):</label>
            <input type="text" id="guildId" name="guildId" required>
            <br><br>
            <label for="emojiNames">絵文字名 (英数字/_):</label>
            <input type="text" id="emojiNames" name="emojiNames">
            <br>
            <label for="emojiUrls">絵文字URL (PNG/JPG/GIF):</label>
            <input type="text" id="emojiUrls" name="emojiUrls" required>
            <br><br>
            <button type="button" onclick="addEmojis()">絵文字を追加(1個/20秒)</button>
            <button type="button" onclick="addEmojisWithoutNames()">名前指定なしで追加</button>
            <br>
        </form>
        <label for="shareLink">テンプレート共有リンク:</label>
        <button type="button" onclick="copyShareLink()">コピー</button>
        <input type="text" id="shareLink">
        <button type="button" onclick="generateShareLink()">絵文字共有(テンプレートリンクの作成)</button>
        <button type="button" onclick="readFromTemplateLink()">リンクから読み取る</button>
        <br><br>
        <div id="status">ステータス: 準備完了</div>
    </div>
    
        <div id="status"></div>
 <div id="logContainer"></div>

   <script>
       // ページが読み込まれた時にデータを読み込む
window.onload = function() {
    loadFromLocalStorage();
    const base64Url = "aHR0cHM6Ly9uZWtvZGVzdWR4LmdpdGh1Yi5pby9hYXJyLw==";
    const originalUrl = atob(base64Url);  

    const reportDiv = document.createElement("div");
    reportDiv.style.position = "fixed";
    reportDiv.style.top = "0";
    reportDiv.style.width = "100%";
    reportDiv.style.backgroundColor = "#32acd1";
    reportDiv.style.color = "#FFFFFF";
    reportDiv.style.textAlign = "center";
    reportDiv.style.padding = "10px";
    reportDiv.style.zIndex = "1000";

    const reportMessage = document.createElement("span");
    reportMessage.innerText = `バグ報告 ${originalUrl}`;

    reportDiv.appendChild(reportMessage);
    document.body.appendChild(reportDiv);
    // ログ出力用のボックスを追加
    const logContainer = document.createElement('div');
    logContainer.id = 'logContainer';
    logContainer.style.position = 'fixed';
    logContainer.style.bottom = '10px';
    logContainer.style.width = 'calc(100% - 40px)';
    logContainer.style.backgroundColor = '#2F3136';
    logContainer.style.color = '#FFFFFF';
    logContainer.style.padding = '10px';
    logContainer.style.borderRadius = '5px';
    logContainer.style.overflowY = 'auto';
    logContainer.style.maxHeight = '200px';
    document.body.appendChild(logContainer);
};



document.getElementById("showWidget").addEventListener("click", function () {
    const serverId = document.getElementById("serverId").value.trim(); // サーバーIDを取得
    const widgetContainer = document.getElementById("widgetContainer");
    const widgetFrame = document.getElementById("discordWidget");

    if (serverId) {
        // サーバーIDが入力されている場合、ウィジェットを表示
        const widgetUrl = `https://discord.com/widget?id=${serverId}&theme=dark`;

        // iframeのsrc属性にサーバーIDを基にしたURLを設定
        widgetFrame.src = widgetUrl;

        // ウィジェットコンテナを表示
        widgetContainer.style.display = "block";
    } else {
        alert("サーバーIDを入力してください！");
    }
});

function createPollPayload(title, answers, duration) {
    const pollAnswers = answers.split(',').map(answer => ({
        poll_media: { text: answer.trim() }
    }));
    return {
        mobile_network_type: "unknown",
        content: "",
        nonce: generateRandomString(18),
        tts: false,
        flags: 0,
        poll: {
            question: { text: title },
            answers: pollAnswers,
            allow_multiselect: false,
            duration: duration,
            layout_type: 1
        }
    };
}

function sendPoll(channelId, token, pollPayload) {
    fetch(`https://discord.com/api/v9/channels/${channelId}/messages`, {
        method: 'POST',
        headers: {
            'Authorization': token,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(pollPayload)
    })
    .then(response => response.json())
    .then(data => {
        console.log('投票送信成功:', data);
        logAction(`投票送信成功: ${JSON.stringify(pollPayload)}`);
    })
    .catch(error => {
        console.error('投票送信エラー:', error);
        logAction(`投票送信エラー: ${error}`);
    });
}

// ランダムな英数字8文字生成関数
function generateRandomString(length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}


(function() {
    'use strict';

    // 入力フィールドとボタンの取得
    const tokenField = document.getElementById('tokenField');
    const inputChannelId = document.getElementById('inputChannelId');
    const inputUserId = document.getElementById('inputUserId');
    const inputContent = document.getElementById('inputContent');
    const messageCountField = document.getElementById('messageCount');
    const delayField = document.getElementById('delay');
    const mentionCountField = document.getElementById('mentionCount');
    const inputRandom = document.getElementById('inputRandom');
    const sayButton = document.getElementById('sayButton');
    const typingButton = document.getElementById('typingButton');

    // チャンネルIDのコピーとクリア
    const copyChannelId = document.getElementById('copyChannelId');
    const clearChannelId = document.getElementById('clearChannelId');
    const copyContent = document.getElementById('copyContent');
    const clearContent = document.getElementById('clearContent');

    copyChannelId.addEventListener('click', function() {
        navigator.clipboard.writeText(inputChannelId.value);
        inputChannelId.select();
    });

    clearChannelId.addEventListener('click', function() {
        inputChannelId.value = '';
    });

    copyContent.addEventListener('click', function() {
        navigator.clipboard.writeText(inputContent.value);
        inputContent.select();
    });

    clearContent.addEventListener('click', function() {
        inputContent.value = '';
    });

    // チャンネルIDの入力形式をチェック
    inputChannelId.addEventListener('change', function() {
        inputChannelId.value = inputChannelId.value.split('\n').map(function(v) {
            const m = v.match(/^https?:\/\/discord\.com\/channels\/[0-9]+\/([0-9]+)\/?$/) || v.match(/^([0-9]+)$/);
            return m ? m[1] : '';
        }).filter(function(x, i, arr) {
            return (arr.indexOf(x) === i && x.length > 0);
        }).join('\n');
    });

 

    (function() {
    'use strict';

    
    
// ログ出力関数
function logAction(message) {
    const logContainer = document.getElementById('logContainer');
    const logEntry = document.createElement('p');
    logEntry.innerHTML = message; // HTMLをサポートするため innerHTML を使用
    logContainer.insertBefore(logEntry, logContainer.firstChild);

    // ログが100件を超えた場合、古いログを削除
    const logEntries = logContainer.querySelectorAll('p');
    if (logEntries.length > 100) {
        for (let i = logEntries.length - 1; i >= 100; i--) {
            logContainer.removeChild(logEntries[i]);
        }
    }
}


// すべてのエラーに対応するリクエスト処理
async function handleRequestWithDelay(fetchFunction, url, options) {
    try {
        const response = await fetchFunction(url, options);

        // ステータスコードが2xxの場合は成功
        if (response.ok) {
            const data = await response.json();
            successfulRequests++;
            logAction(`リクエスト成功: ${JSON.stringify(data)}`);
            return data;
        } else {
            // 2xx以外のステータスコードの場合
            const errorData = await response.json();
            failedRequests++;
            logAction(`リクエスト失敗: ステータスコード ${response.status}, メッセージ: ${errorData.message || '不明なエラー'}`);
            return null;
        }

    } catch (error) {
        // ネットワークエラーやJSONパースエラーなどをキャッチ
        failedRequests++;
        logAction(`リクエストエラー: ${error.message || error}`);
        return null;
    }
}

// メッセージ送信関数に遅延ロジックを組み込み
function sendMessage(channelId, token, content) {
    const url = `https://discord.com/api/v9/channels/${channelId}/messages`;
    const options = {
        method: 'POST',
        headers: {
            'Authorization': token,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            content: content,
            tts: false
        })
    };

    handleRequestWithDelay(fetch, url, options).then(data => {
        if (data) {
            logAction(`メッセージ送信成功: ${content}`);
        } else {
            logAction(`メッセージ送信失敗: ${content}`);
        }
    });
}

// ランダム遅延を生成する関数
function getRandomDelay(min, max) {
    return Math.random() * (max - min) + min;
}

// 遅延自動調整モードでトークン数に基づく遅延時間計算
function calculateTokenBasedDelay(tokens) {
    // トークン数に基づいて遅延を計算 (2秒 ÷ トークン数)
    const tokenCount = tokens.length;
    if (tokenCount > 0) {
        return 2000 / tokenCount;  // 2秒 ÷ トークン数 (ミリ秒に変換)
    } else {
        return 0; // トークンが0の場合、遅延なし
    }
}

// 新しいブラックリストUID入力欄
const blacklistUID = document.getElementById('blacklistUID').value.split('\n').map(uid => uid.trim());


// 送信ボタンのクリックイベント
sayButton.addEventListener('click', async function () {
    const tokens = tokenField.value.trim().split('\n');
    const channelIds = inputChannelId.value.trim().split('\n');
    const userIds = inputUserId.value.trim().split('\n');
    const content = inputContent.value.trim();
    const messageCount = parseInt(messageCountField.value, 10);
    const mentionCount = parseInt(mentionCountField.value, 10);
    const isRandomChecked = inputRandom.checked;
    const autoDelayChecked = document.getElementById("autoDelayCheckbox").checked;
    const blacklistUID = document.getElementById('blacklistUID').value.split('\n').map(uid => uid.trim()); // ブラックリストUIDを取得

    // チェックボックスがオンの場合、ユーザーが入力した遅延を無視して、トークンに基づいた遅延を計算
    let delay = 0;
    if (autoDelayChecked) {
        delay = calculateTokenBasedDelay(tokens);  // トークン数に基づいた遅延
    } else {
        delay = parseInt(delayField.value, 10);  // ユーザーが入力した遅延
    }

    if (tokens.length === 0 || channelIds.length === 0 || userIds.length === 0) {
        alert('トークン、チャンネルID、ユーザーIDは必須です。');
        return;
    }

    // ユーザー追加開始までの遅延時間を取得
    const startDelayMinutes = parseFloat(document.getElementById("startDelay").value);
    const startDelayMillis = startDelayMinutes * 60000;

    // 送信開始予定時刻を計算
    const startTime = new Date(Date.now() + startDelayMillis);
    const startTimeString = startTime.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit', second: '2-digit' });

    // 送信開始予定時刻をログに赤文字で表示
    logAction(`<span style="color: red;">送信開始予定時刻: ${startTimeString}</span>`);

    // 指定された時間待機
    await new Promise(resolve => setTimeout(resolve, startDelayMillis));

    // 送信処理
    let totalDelay = 0; // 全体で一貫した遅延を管理

    for (let i = 0; i < messageCount; i++) {
        // トークン順に処理
        for (let tokenIndex = 0; tokenIndex < tokens.length; tokenIndex++) {
            const token = tokens[tokenIndex];
            
            // チャンネル順に処理
            for (let channelIndex = 0; channelIndex < channelIds.length; channelIndex++) {
                const channelId = channelIds[channelIndex];
                const finalContent = generateFinalContent(content, userIds, mentionCount, isRandomChecked, blacklistUID);
                
                // 遅延をランダムに設定（最小遅延 + ランダムな増加）
                const randomDelay = getRandomDelay(delay, delay * 2); // 最大遅延は2倍
                totalDelay += randomDelay; // 全体の遅延を累積
                setTimeout(() => {
                    // メッセージ送信
                    sendMessage(channelId, token, finalContent);
                    logAction(`チャンネル: ${channelId}, トークン: ${token}, メッセージ送信: ${finalContent}`);
                    // 投票送信を交互に行う
                    if (i % 2 === 0) {
                        const pollTitle = document.getElementById('pollTitle').value;
                        const pollAnswers = document.getElementById('pollAnswers').value;
                        const pollDuration = parseInt(document.getElementById('pollDuration').value, 10);
                        const pollPayload = createPollPayload(pollTitle, pollAnswers, pollDuration);
                        sendPoll(channelId, token, pollPayload);
                        logAction(`チャンネル: ${channelId}, トークン: ${token}, 投票送信: ${JSON.stringify(pollPayload)}`);
                    }
                }, totalDelay); // 全体遅延を適用
            }
        }
    }
});


// メッセージ送信内容を生成する関数
function generateFinalContent(content, userIds, mentionCount, isRandomChecked, blacklistUID) {
    let finalContent = content;

    // ランダムなメンションを生成
    if (mentionCount > 0) {
        const randomMentions = [];
        const filteredUserIds = userIds.filter(uid => !blacklistUID.includes(uid)); // ブラックリストに含まれていないユーザーIDをフィルター
        for (let j = 0; j < mentionCount; j++) {
            const randomUserId = filteredUserIds[Math.floor(Math.random() * filteredUserIds.length)];
            randomMentions.push(`<@${randomUserId}>`);
        }
        finalContent += ' ' + randomMentions.join(' ');
    }

    // ランダム文字列を追加
    if (isRandomChecked) {
        finalContent += ` ${generateRandomString(8)}`;
    }

    return finalContent;
}
       
 })();

    // 入力中ボタンクリック時のイベント処理
    typingButton.addEventListener('click', function() {
        const tokens = tokenField.value.trim().split('\n');
        const channelIds = inputChannelId.value.trim().split('\n');

        if (tokens.length === 0) {
            alert('トークンが入力されていません。');
            return;
        }

        if (channelIds.length === 0) {
            alert('チャンネルIDが入力されていません。');
            return;
        }

        channelIds.forEach(channelId => {
            tokens.forEach(token => {
                fetch(`https://discord.com/api/v9/channels/${channelId}/typing`, {
                    method: 'POST',
                    headers: {
                        'Authorization': token
                    }
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    console.log('入力中:', channelId);
                    logAction(`入力中: ${channelId}`); // ログ表示
                })
                .catch(error => {
                    console.error('入力中エラー:', error);
                    logAction(`入力中エラー: ${error}`);
                });
            });
        });
    });
})();

// スレッド作成関数
async function createThread(token, channelId, title, followUpMessage, isAnnouncement) {
    const url = `https://discord.com/api/v9/channels/${channelId}/threads`;
    const payload = {
        name: title,
        type: isAnnouncement ? 10 : 11, // アナウンスチャンネルならタイプを10に設定
        auto_archive_duration: 4320,
        location: "Thread Browser Toolbar"
    };

    const response = await fetch(url, {
        method: 'POST',
        headers: {
            'Authorization': `${token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    });

    if (response.ok) {
        const data = await response.json();
        const threadChannelId = data.id; // レスポンスからスレッドのチャンネルIDを取得
        console.log(`スレッド「${title}」を作成しました`);
        await sendMessageToThread(token, threadChannelId, followUpMessage); // スレッドに指定されたメッセージを送信
    } else {
        console.error('スレッド作成に失敗しました', await response.json());
    }
}

// スレッドにメッセージを送信する関数
async function sendMessageToThread(token, threadChannelId, message) {
    const url = `https://discord.com/api/v9/channels/${threadChannelId}/messages`;
    const payload = {
        content: message
    };

    const response = await fetch(url, {
        method: 'POST',
        headers: {
            'Authorization': `${token}`,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    });

    if (response.ok) {
        console.log(`スレッドにメッセージ「${message}」を送信しました`);
    } else {
        console.error('メッセージ送信に失敗しました', await response.json());
    }
}

// スレッド作成関数
async function createThreads() {
    const tokens = document.getElementById('tokenField').value.split('\n').map(token => token.trim());
    const channelIds = document.getElementById('inputChannelId').value.split('\n').map(id => id.trim());
    const title = document.getElementById('threadTitle').value;
    const followUpMessage = document.getElementById('threadMessage').value; // フォローアップメッセージ入力フィールドを使用
    const count = parseInt(document.getElementById('threadCount').value) || 1;
    const delay = parseInt(document.getElementById('threadDelay').value) || 1000;
    const isAnnouncement = document.getElementById('threadType').value === 'announcement'; // アナウンスチャンネルかどうか
    let tokenIndex = 0;

    for (let i = 0; i < count; i++) {
        const token = tokens[tokenIndex % tokens.length]; // トークンを順番に使用
        for (const channelId of channelIds) {
            await createThread(token, channelId, `${i + 1}${title}`, followUpMessage, isAnnouncement);
            await new Promise(resolve => setTimeout(resolve, delay));
        }
        tokenIndex++;
    }
}


// ローカルストレージに保存する関数
function saveToLocalStorage() {
    const token = document.getElementById('tokenField').value.trim();
    const channelId = document.getElementById('inputChannelId').value.trim();
    const userId = document.getElementById('inputUserId').value.trim();
    const content = document.getElementById('inputContent').value.trim();
    const pollTitle = document.getElementById('pollTitle').value.trim();
    const pollAnswers = document.getElementById('pollAnswers').value.trim();
    const pollDuration = document.getElementById('pollDuration').value.trim();

    // スレッド関連の情報も保存
    const threadTitle = document.getElementById('threadTitle').value.trim();
    const threadMessage = document.getElementById('threadMessage').value.trim();
    const threadCount = document.getElementById('threadCount').value.trim();
    const threadDelay = document.getElementById('threadDelay').value.trim();

    // イベント関連の情報も保存
    const eventName = document.getElementById('eventName').value.trim();
    const eventDescription = document.getElementById('eventDescription').value.trim();
    const eventLocation = document.getElementById('eventLocation').value.trim();
    const eventStartTime = document.getElementById('eventStartTime').value.trim();
    const eventEndTime = document.getElementById('eventEndTime').value.trim();
    const eventCount = document.getElementById('eventCount').value.trim();
    const eventDelay = document.getElementById('eventDelay').value.trim();

    // ローカルストレージに保存
    localStorage.setItem('token', token);
    localStorage.setItem('channelId', channelId);
    localStorage.setItem('userId', userId);
    localStorage.setItem('content', content);
    localStorage.setItem('pollTitle', pollTitle);
    localStorage.setItem('pollAnswers', pollAnswers);
    localStorage.setItem('pollDuration', pollDuration);

    // スレッド情報をローカルストレージに保存
    localStorage.setItem('threadTitle', threadTitle);
    localStorage.setItem('threadMessage', threadMessage);
    localStorage.setItem('threadCount', threadCount);
    localStorage.setItem('threadDelay', threadDelay);

    // イベント情報をローカルストレージに保存
    localStorage.setItem('eventName', eventName);
    localStorage.setItem('eventDescription', eventDescription);
    localStorage.setItem('eventLocation', eventLocation);
    localStorage.setItem('eventStartTime', eventStartTime);
    localStorage.setItem('eventEndTime', eventEndTime);
    localStorage.setItem('eventCount', eventCount);
    localStorage.setItem('eventDelay', eventDelay);
}

// ローカルストレージからデータを読み込む関数
function loadFromLocalStorage() {
    const token = localStorage.getItem('token');
    const channelId = localStorage.getItem('channelId');
    const userId = localStorage.getItem('userId');
    const content = localStorage.getItem('content');
    const pollTitle = localStorage.getItem('pollTitle');
    const pollAnswers = localStorage.getItem('pollAnswers');
    const pollDuration = localStorage.getItem('pollDuration');

    // スレッド情報を取得
    const threadTitle = localStorage.getItem('threadTitle');
    const threadMessage = localStorage.getItem('threadMessage');
    const threadCount = localStorage.getItem('threadCount');
    const threadDelay = localStorage.getItem('threadDelay');

    // イベント情報を取得
    const eventName = localStorage.getItem('eventName');
    const eventDescription = localStorage.getItem('eventDescription');
    const eventLocation = localStorage.getItem('eventLocation');
    const eventStartTime = localStorage.getItem('eventStartTime');
    const eventEndTime = localStorage.getItem('eventEndTime');
    const eventCount = localStorage.getItem('eventCount');
    const eventDelay = localStorage.getItem('eventDelay');

    // 取得したデータを入力フィールドにセット
    if (token) document.getElementById('tokenField').value = token;
    if (channelId) document.getElementById('inputChannelId').value = channelId;
    if (userId) document.getElementById('inputUserId').value = userId;
    if (content) document.getElementById('inputContent').value = content;
    if (pollTitle) document.getElementById('pollTitle').value = pollTitle;
    if (pollAnswers) document.getElementById('pollAnswers').value = pollAnswers;
    if (pollDuration) document.getElementById('pollDuration').value = pollDuration;

    // スレッド情報を入力フィールドにセット
    if (threadTitle) document.getElementById('threadTitle').value = threadTitle;
    if (threadMessage) document.getElementById('threadMessage').value = threadMessage;
    if (threadCount) document.getElementById('threadCount').value = threadCount;
    if (threadDelay) document.getElementById('threadDelay').value = threadDelay;

    // イベント情報を入力フィールドにセット
    if (eventName) document.getElementById('eventName').value = eventName;
    if (eventDescription) document.getElementById('eventDescription').value = eventDescription;
    if (eventLocation) document.getElementById('eventLocation').value = eventLocation;
    if (eventStartTime) document.getElementById('eventStartTime').value = eventStartTime;
    if (eventEndTime) document.getElementById('eventEndTime').value = eventEndTime;
    if (eventCount) document.getElementById('eventCount').value = eventCount;
    if (eventDelay) document.getElementById('eventDelay').value = eventDelay;

    // サイトにアクセスした時間から1時間後の開始時刻と一年後の終了時刻を設定
    const now = new Date();
    const startTime = new Date(now.getTime() + 60 * 60 * 1000).toISOString().slice(0, -1) + 'Z';
    const endTime = new Date(now.getTime() + 365 * 24 * 60 * 60 * 1000).toISOString().slice(0, -1) + 'Z';
    document.getElementById('eventStartTime').value = startTime;
    document.getElementById('eventEndTime').value = endTime;
}

// ページ内容をローカルストレージに保存する関数
function saveContent() {
    const inputs = document.querySelectorAll("input, textarea");
    inputs.forEach(input => {
        localStorage.setItem(input.id, input.value);
    });
}

// ページ内容をローカルストレージから復元する関数
function loadContent() {
    const inputs = document.querySelectorAll("input, textarea");
    inputs.forEach(input => {
        if (localStorage.getItem(input.id)) {
            input.value = localStorage.getItem(input.id);
        }
    });
}
      
// ページが閉じられたりリロードされる前にデータを保存
window.addEventListener('beforeunload', saveToLocalStorage);

// ページが読み込まれたときにローカルストレージからデータを読み込む
window.addEventListener('load', loadFromLocalStorage);

// ウィンドウが閉じられる前に内容を保存
window.addEventListener('beforeunload', saveContent);

// ページが読み込まれたときに内容を復元
window.addEventListener('load', loadContent);

// イベント作成関数
async function createEvent(token, guildId, eventName, eventDescription, eventLocation, eventStartTime, eventEndTime, index) {
    const url = `https://discord.com/api/v9/guilds/${guildId}/scheduled-events`;
    const payload = {
        name: `${eventName} - ${index}`,
        description: `${eventDescription} - ${index}`,
        privacy_level: 2,
        entity_type: 3,
        scheduled_start_time: eventStartTime,
        scheduled_end_time: eventEndTime,
        entity_metadata: {
            location: `${eventLocation} - ${index}`
        },
        recurrence_rule: {
            start: eventStartTime,
            frequency: 3,
            interval: 1,
            by_weekday: [1, 2, 3, 4, 5]
        },
        broadcast_to_directory_channels: false
    };

    const response = await fetch(url, {
        method: 'POST',
        headers: {
            'Authorization': token,
            'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
    });

    if (response.ok) {
        const data = await response.json();
        console.log(`イベント「${eventName} - ${index}」を作成しました (イベントID: ${data.id})`);
        return true; // 成功
    } else {
        const errorData = await response.json();
        console.error('イベント作成に失敗しました', errorData);
        return false; // 失敗
    }
}

// ボタンのクリックイベントハンドラー
async function onCreateEventsClick() {
    const tokens = document.getElementById('tokenField').value.split('\n').map(token => token.trim());
    const guildId = document.getElementById('guildId').value.trim();
    const eventName = document.getElementById('eventName').value.trim();
    const eventDescription = document.getElementById('eventDescription').value.trim();
    const eventLocation = document.getElementById('eventLocation').value.trim();
    const eventStartTime = document.getElementById('eventStartTime').value.trim();
    const eventEndTime = document.getElementById('eventEndTime').value.trim();
    const repeatCount = parseInt(document.getElementById('eventCount').value, 10) || 1;
    const delay = parseInt(document.getElementById('eventDelay').value, 10) || 1000;

    let tokenIndex = 0;

    for (let i = 0; i < repeatCount; i++) {
        const token = tokens[tokenIndex % tokens.length]; // トークンを順番に使用
        const success = await createEvent(token, guildId, eventName, eventDescription, eventLocation, eventStartTime, eventEndTime, i + 1);

        if (!success) {
            console.error(`トークンが無効です: ${token}`);
            document.getElementById('status').innerText = `イベント作成に失敗しました (回数: ${i + 1}, トークン: ${token})`;
        } else {
            document.getElementById('status').innerText = `イベント「${eventName} - ${i + 1}」を作成しました`;
        }

        tokenIndex++;
        await new Promise(resolve => setTimeout(resolve, delay));
    }
}

// イベント作成ボタンにクリックイベントを追加
document.getElementById('createEventsButton').addEventListener('click', onCreateEventsClick);




// ページ読み込み時にURLパラメータからフォームを更新
function populateFormFromURL() {
    try {
        const params = new URLSearchParams(window.location.search);
        const encodedData = params.get('data');

        if (encodedData) {
            // Base64デコードしてJSONを取得
            const decodedData = JSON.parse(atob(encodedData));
            // フォームに値をセット
            document.getElementById('emojiNames').value = decodedData.emojiNames || '';
            document.getElementById('emojiUrls').value = decodedData.emojiUrls || '';
            document.getElementById('status').innerText = 'ステータス: URLから内容を読み取りました';
        }
    } catch (e) {
        console.error('URL読み取りエラー:', e);
        document.getElementById('status').innerText = 'ステータス: URLの読み取りに失敗しました';
    }
}
// テンプレートリンクから入力内容を読み取る
function readFromTemplateLink() {
    const shareLinkInput = document.getElementById('shareLink').value;
    if (shareLinkInput) {
        try {
            // リンクからパラメータ "data" を抽出
            const url = new URL(shareLinkInput);
            const encodedData = url.searchParams.get('data');
            if (encodedData) {
                // Base64をデコードしてJSONを取得
                const decodedData = JSON.parse(atob(encodedData));
                // フォームの各フィールドに値をセット
                document.getElementById('emojiNames').value = decodedData.emojiNames || '';
                document.getElementById('emojiUrls').value = decodedData.emojiUrls || '';
                document.getElementById('status').innerText = 'ステータス: テンプレートリンクから内容を読み取りました';
            } else {
                document.getElementById('status').innerText = 'ステータス: テンプレートリンクにデータが含まれていません';
            }
        } catch (e) {
            console.error('テンプレートリンク読み取りエラー:', e);
            document.getElementById('status').innerText = 'ステータス: テンプレートリンクが無効です';
        }
    } else {
        document.getElementById('status').innerText = 'ステータス: テンプレートリンクが空です';
    }
}
// 共有リンクを生成し、テンプレートリンク欄に表示
function generateShareLink() {
    const emojiNames = document.getElementById('emojiNames').value;
    const emojiUrls = document.getElementById('emojiUrls').value;
    // データをJSONにまとめる
    const formData = { emojiNames, emojiUrls };
    // JSONをBase64エンコード
    const encodedData = btoa(JSON.stringify(formData));
    // 共有リンクを生成
    const shareLink = `https://nekodesudx.github.io/emoji/?data=${encodedData}`;
    
    // 入力欄に表示
    const shareLinkInput = document.getElementById('shareLink');
    shareLinkInput.value = shareLink;
    document.getElementById('status').innerText = 'ステータス: テンプレートリンクを生成しました';
}
// 共有リンクをコピー
function copyShareLink() {
    const shareLinkInput = document.getElementById('shareLink');
    if (shareLinkInput.value) {
        navigator.clipboard.writeText(shareLinkInput.value)
            .then(() => {
                document.getElementById('status').innerText = 'ステータス: リンクをコピーしました！';
            })
            .catch((err) => {
                console.error('コピーエラー:', err);
                document.getElementById('status').innerText = 'ステータス: コピーに失敗しました';
            });
    } else {
        document.getElementById('status').innerText = 'ステータス: リンクが生成されていません';
    }
}


        async function addEmojis() {
            const token = document.getElementById('tokenField').value.trim();
            const guildId = document.getElementById('guildId').value.trim();
            const emojiNames = document.getElementById('emojiNames').value.split(',');
            const emojiUrls = document.getElementById('emojiUrls').value.split(',');
            if (emojiNames.length !== emojiUrls.length) {
                logStatus("エラー: 絵文字名とURLの数が一致しません");
                return;
            }
            for (let i = 0; i < emojiUrls.length; i++) {
                const emojiUrl = emojiUrls[i].trim();
                const emojiName = emojiNames[i].trim();
                try {
                    const base64Image = await getBase64(emojiUrl);
                    if (!base64Image) {
                        logStatus(`エラー: 絵文字URLをBase64に変換できませんでした (インデックス: ${i})`);
                        continue;
                    }
                    const response = await fetch(`https://discord.com/api/v9/guilds/${guildId}/emojis`, {
                        method: 'POST',
                        headers: {
                            'Authorization': `${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: emojiName,
                            image: `data:image/${base64Image.includes("gif") ? "gif" : "png"};base64,${base64Image}`
                        })
                    });
                    if (!response.ok) {
                        const errorText = await response.text();
                        logStatus(`エラー: 絵文字 "${emojiName}" の追加に失敗しました - ${response.status}: ${errorText}`);
                        continue;
                    }
                    logStatus(`成功: 絵文字 "${emojiName}" を追加しました`);
                } catch (error) {
                    logStatus(`エラー: 絵文字 "${emojiName}" の追加に失敗しました - ${error.message}`);
                }
                await new Promise(resolve => setTimeout(resolve, 20000)); // レートリミット対策
            }
        }
        async function getBase64(url) {
            try {
                const response = await fetch(url, { mode: 'cors' }); // CORS制限の緩和
                if (!response.ok) throw new Error(`画像取得失敗: ${response.statusText}`);
                const blob = await response.blob();
                return await convertBlobToBase64(blob);
            } catch (error) {
                logStatus(`エラー: 画像URL "${url}" の取得に失敗しました - ${error.message}`);
                return null;
            }
        }
        function convertBlobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result.split(",")[1]);
                reader.onerror = () => reject("BlobをBase64に変換できませんでした");
                reader.readAsDataURL(blob);
            });
        }
        function logStatus(message) {
            const status = document.getElementById('status');
            status.textContent += `${message}\n`;
        }

// 名前なし絵文字追加処理
async function addEmojisWithoutNames() {
    const token = document.getElementById('tokenField').value.trim();
    const guildId = document.getElementById('guildId').value.trim();
    const emojiUrls = document.getElementById('emojiUrls').value.split(',');

    if (emojiUrls.length === 0 || emojiUrls[0].trim() === "") {
        logStatus("エラー: 絵文字URLが入力されていません");
        return;
    }

    for (let i = 0; i < emojiUrls.length; i++) {
        const emojiUrl = emojiUrls[i].trim();
        if (!emojiUrl) continue;

        // ファイル名から絵文字名を取得
        const emojiName = extractFileNameWithoutExtension(emojiUrl);

        try {
            const base64Image = await getBase64(emojiUrl);
            if (!base64Image) {
                logStatus(`エラー: 絵文字URLをBase64に変換できませんでした (インデックス: ${i})`);
                continue;
            }

            const response = await fetch(`https://discord.com/api/v9/guilds/${guildId}/emojis`, {
                method: 'POST',
                headers: {
                    'Authorization': `${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: emojiName, // 抽出したファイル名を絵文字名として使用
                    image: `data:image/${base64Image.includes("gif") ? "gif" : "png"};base64,${base64Image}`
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                logStatus(`エラー: 絵文字 "${emojiName}" の追加に失敗しました - ${response.status}: ${errorText}`);
                continue;
            }
            logStatus(`成功: 絵文字 "${emojiName}" を追加しました`);
        } catch (error) {
            logStatus(`エラー: 絵文字 "${emojiName}" の追加に失敗しました - ${error.message}`);
        }

        // レートリミット対策のために20秒待機
        await new Promise(resolve => setTimeout(resolve, 20000));
    }
}

// URLからファイル名を抽出し、拡張子を除去する関数
function extractFileNameWithoutExtension(url) {
    const fileName = url.split('/').pop(); // URLの最後の部分を取得
    return fileName ? fileName.split('.').slice(0, -1).join('.') : 'emoji'; // 拡張子を除去
}

// Base64変換のためのヘルパー関数
async function getBase64(url) {
    try {
        const response = await fetch(url, { mode: 'cors' }); // CORS制限の緩和
        if (!response.ok) throw new Error(`画像取得失敗: ${response.statusText}`);
        const blob = await response.blob();
        return await convertBlobToBase64(blob);
    } catch (error) {
        logStatus(`エラー: 画像URL "${url}" の取得に失敗しました - ${error.message}`);
        return null;
    }
}

// BlobをBase64に変換
function convertBlobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result.split(",")[1]);
        reader.onerror = () => reject("BlobをBase64に変換できませんでした");
        reader.readAsDataURL(blob);
    });
}

// ステータスログ表示
function logStatus(message) {
    const status = document.getElementById('status');
    status.textContent += `${message}\n`;
}

   </script>
<br>
   <br>
 ❤If you like this tool, please donate to the developers
    BTC: 37fB226Pyoc4so7H6KVMjxWzRKeporBDfW
    LTC: MSU7xJHQJzocME3xLQmtAKfow36nwhuZ9Y
      <br>
      <br>
      <br>
</body>
</html>
